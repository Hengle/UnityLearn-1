# UnityProject

# 基础公共
## 本地文本写入工具
## 本地数据存储工具
## 存储格式：json、
## 传输格式：protobuf（偏向于protobuf，保证前后台的类型一致，前端不必重复建立数据类型）
## json 解析方式
## 多语言本地化 LanguageService
## 资源管理 AssetService 
- 开发期间使用Resource.Load()从本地加载资源，提高开发效率
- 线上的产品使用AssetBundle做资源的热更
## xLua做代码热更（ILRuntime受限于平台）
## async实现异步编程
## 开发测试日志系统打印工具
## 线上错误日志异常捕获统计系统 
## 用户业务模块停留时长监控系统（屏幕对角线开启 替代 画圈开启）
## 客户端时间戳
## SDK 原生与unity的通信 
## 音乐、音效管理
## 异形屏幕适配，统计系统
## 数据加密方式
## 独立效果UI层，弹窗层（分层策略）
## 公共弹窗

## 工厂模式 来设计UI框架

# 基本信息
## 设备信息类
### 设备号码
### 设备名称
### 是否为异形屏幕/刘海区域坐标

## 用户设置信息
### 音效开启
### 音乐开启
### 画质高低
### 语言


# 玩家信息
## ID
## token



# 代码规范
- 命名规范
- 不使用foreach
1,老生常谈的string,在字符串过多或者经常使用同一字符串进行 + 操作,需要换成StringBuilder.string在两个字符串连接的过程，其实是生成一个新的字符串的过程。而之前的旧的字符串自然而然就成为了垃圾。而作为引用类型的字符串，其空间是在堆上分配的，被弃置的旧的字符串的空间会被GC当做垃圾回收.StringBuilder则不会生成一个新的实例对象.
2,尽量不要使用foreach，而是使用for。foreach其实会涉及到迭代器的使用，而据传说每一次循环所产生的迭代器会带来24 Bytes的垃圾。那么循环10次就是240Bytes。
3,不要直接访问gameobject的tag属性。比如if (go.tag == “human”)最好换成if (go.CompareTag (“human”))。因为访问物体的tag属性会在堆上额外的分配空间。如果在循环中这么处理，留下的垃圾就可想而知了。
4,不要经常性的创建销毁对象,需要做一个对象管理池,复杂一些的就是生产者消费者模式.简单点的就是3个对象来回复用.
5,不使用LINQ命令，因为它们一般会分配中间缓器，而这很容易生成垃圾内存。
6,C#与C++交互的时候,①由C#创建内存,传入C++函数:托管内存转为非托管内存,以及操作非托管内存的时候,需要特别精细的控制.GCHandle gch = GCHandle.Alloc(...)标记某块内存地址不会被GC,并且固定其内存地址(不会被 堆 移动压缩),表示托管内存转化为非托管内存.调用gch.Free();函数,表示非托管内存转化为托管内存.②  由C++创建内存,回调到C#函数:使用IntPtr.Zero作为指针类型,配合out参数,使用Marshal.Copy(...)函数将非托管内存转化为托管内存在C#中使用,使用Marshal.FreeHGlobal(...)释放非托管内存.③在C#中申请一块非托管内存给C++使用,调用Marshal.AllocHGlobal(..)函数.

# 打赏
